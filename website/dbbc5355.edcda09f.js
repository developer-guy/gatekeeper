(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{67:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(2),i=n(6),o=(n(0),n(71)),r={id:"howto",title:"How to use Gatekeeper"},s={unversionedId:"howto",id:"howto",isDocsHomePage:!1,title:"How to use Gatekeeper",description:"How to Use Gatekeeper",source:"@site/docs/howto.md",slug:"/howto",permalink:"/gatekeeper/website/docs/howto",editUrl:"https://sozercan.github.io/gatekeeper/website/docs/docs/howto.md",version:"current",sidebar:"someSidebar",previous:{title:"Examples",permalink:"/gatekeeper/website/docs/examples"},next:{title:"Policy Library",permalink:"/gatekeeper/website/docs/library"}},l=[{value:"How to Use Gatekeeper",id:"how-to-use-gatekeeper",children:[{value:"Constraint Templates",id:"constraint-templates",children:[]},{value:"Constraints",id:"constraints",children:[]},{value:"Replicating Data",id:"replicating-data",children:[]},{value:"Audit",id:"audit",children:[]},{value:"Log denies",id:"log-denies",children:[]},{value:"Dry Run",id:"dry-run",children:[]},{value:"Exempting Namespaces from Gatekeeper",id:"exempting-namespaces-from-gatekeeper",children:[]},{value:"Debugging",id:"debugging",children:[]},{value:"Enable Delete Operations",id:"enable-delete-operations",children:[]},{value:"Customizing Admission Behavior",id:"customizing-admission-behavior",children:[]},{value:"Emergency Recovery",id:"emergency-recovery",children:[]},{value:"Running on private GKE Cluster nodes",id:"running-on-private-gke-cluster-nodes",children:[]},{value:"Running on OpenShift 4.x",id:"running-on-openshift-4x",children:[]}]}],c={rightToc:l};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"how-to-use-gatekeeper"},"How to Use Gatekeeper"),Object(o.b)("p",null,"Gatekeeper uses the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/open-policy-agent/frameworks/tree/master/constraint"}),"OPA Constraint Framework")," to describe and enforce policy. Look there for more detailed information on their semantics and advanced usage."),Object(o.b)("h3",{id:"constraint-templates"},"Constraint Templates"),Object(o.b)("p",null,"Before you can define a constraint, you must first define a ",Object(o.b)("inlineCode",{parentName:"p"},"ConstraintTemplate"),", which describes both the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.openpolicyagent.org/docs/latest/#rego"}),"Rego")," that enforces the constraint and the schema of the constraint. The schema of the constraint allows an admin to fine-tune the behavior of a constraint, much like arguments to a function."),Object(o.b)("p",null,"Here is an example constraint template that requires all labels described by the constraint to be present:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: k8srequiredlabels\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sRequiredLabels\n        listKind: K8sRequiredLabelsList\n        plural: k8srequiredlabels\n        singular: k8srequiredlabels\n      validation:\n        # Schema for the `parameters` field\n        openAPIV3Schema:\n          properties:\n            labels:\n              type: array\n              items: string\n  targets:\n    - target: admission.k8s.gatekeeper.sh\n      rego: |\n        package k8srequiredlabels\n\n        violation[{"msg": msg, "details": {"missing_labels": missing}}] {\n          provided := {label | input.review.object.metadata.labels[label]}\n          required := {label | label := input.parameters.labels[_]}\n          missing := required - provided\n          count(missing) > 0\n          msg := sprintf("you must provide labels: %v", [missing])\n        }\n')),Object(o.b)("p",null,"You can install this ConstraintTemplate with the following command:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/demo/basic/templates/k8srequiredlabels_template.yaml\n")),Object(o.b)("h3",{id:"constraints"},"Constraints"),Object(o.b)("p",null,"Constraints are then used to inform Gatekeeper that the admin wants a ConstraintTemplate to be enforced, and how. This constraint uses the ",Object(o.b)("inlineCode",{parentName:"p"},"K8sRequiredLabels")," constraint template above to make sure the ",Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper")," label is defined on all namespaces:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: ns-must-have-gk\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Namespace"]\n  parameters:\n    labels: ["gatekeeper"]\n')),Object(o.b)("p",null,"You can install this Constraint with the following command:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/demo/basic/constraints/all_ns_must_have_gatekeeper.yaml\n")),Object(o.b)("p",null,"Note the ",Object(o.b)("inlineCode",{parentName:"p"},"match")," field, which defines the scope of objects to which a given constraint will be applied. It supports the following matchers:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"kinds")," accepts a list of objects with ",Object(o.b)("inlineCode",{parentName:"li"},"apiGroups")," and ",Object(o.b)("inlineCode",{parentName:"li"},"kinds")," fields that list the groups/kinds of objects to which the constraint will apply. If multiple groups/kinds objects are specified, only one match is needed for the resource to be in scope."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"scope")," accepts ",Object(o.b)("inlineCode",{parentName:"li"},"*"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Cluster"),", or ",Object(o.b)("inlineCode",{parentName:"li"},"Namespaced")," which determines if cluster-scoped and/or namesapced-scoped resources are selected. (defaults to ",Object(o.b)("inlineCode",{parentName:"li"},"*"),")"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"namespaces")," is a list of namespace names. If defined, a constraint will only apply to resources in a listed namespace."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"excludedNamespaces")," is a list of namespace names. If defined, a constraint will only apply to resources not in a listed namespace."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"labelSelector")," is a standard Kubernetes label selector."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"namespaceSelector")," is a standard Kubernetes namespace selector. If defined, make sure to add ",Object(o.b)("inlineCode",{parentName:"li"},"Namespaces")," to your ",Object(o.b)("inlineCode",{parentName:"li"},"configs.config.gatekeeper.sh")," object to ensure namespaces are synced into OPA. Refer to the ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#replicating-data"}),"Replicating Data section")," for more details.")),Object(o.b)("p",null,"Note that if multiple matchers are specified, a resource must satisfy each top-level matcher (",Object(o.b)("inlineCode",{parentName:"p"},"kinds"),", ",Object(o.b)("inlineCode",{parentName:"p"},"namespaces"),", etc.) to be in scope. Each top-level matcher has its own semantics for what qualifies as a match. An empty matcher is deemed to be inclusive (matches everything). Also understand ",Object(o.b)("inlineCode",{parentName:"p"},"namespaces"),", ",Object(o.b)("inlineCode",{parentName:"p"},"excludedNamespaces"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"namespaceSelector")," will match on cluster scoped resources which are not namespaced. To avoid this adjust the ",Object(o.b)("inlineCode",{parentName:"p"},"scope")," to ",Object(o.b)("inlineCode",{parentName:"p"},"Namespaced"),"."),Object(o.b)("h3",{id:"replicating-data"},"Replicating Data"),Object(o.b)("p",null,"Some constraints are impossible to write without access to more state than just the object under test. For example, it is impossible to know if an ingress's hostname is unique among all ingresses unless a rule has access to all other ingresses. To make such rules possible, we enable syncing of data into OPA."),Object(o.b)("p",null,"The audit feature does not require replication by default. However, when the ",Object(o.b)("inlineCode",{parentName:"p"},"audit-from-cache")," flag is set to true, the OPA cache will be used as the source-of-truth for audit queries; thus, an object must first be cached before it can be audited for constraint violations."),Object(o.b)("p",null,"Kubernetes data can be replicated into OPA via the sync config resource. Currently resources defined in ",Object(o.b)("inlineCode",{parentName:"p"},"syncOnly")," will be synced into OPA. Updating ",Object(o.b)("inlineCode",{parentName:"p"},"syncOnly")," should dynamically update what objects are synced. Below is an example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: config.gatekeeper.sh/v1alpha1\nkind: Config\nmetadata:\n  name: config\n  namespace: "gatekeeper-system"\nspec:\n  sync:\n    syncOnly:\n      - group: ""\n        version: "v1"\n        kind: "Namespace"\n      - group: ""\n        version: "v1"\n        kind: "Pod"\n')),Object(o.b)("p",null,"You can install this config with the following command:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/demo/basic/sync.yaml\n")),Object(o.b)("p",null,"Once data is synced into OPA, rules can access the cached data under the ",Object(o.b)("inlineCode",{parentName:"p"},"data.inventory")," document."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"data.inventory")," document has the following format:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"For cluster-scoped objects: ",Object(o.b)("inlineCode",{parentName:"li"},"data.inventory.cluster[<groupVersion>][<kind>][<name>]"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Example referencing the Gatekeeper namespace: ",Object(o.b)("inlineCode",{parentName:"li"},'data.inventory.cluster["v1"].Namespace["gatekeeper"]')))),Object(o.b)("li",{parentName:"ul"},"For namespace-scoped objects: ",Object(o.b)("inlineCode",{parentName:"li"},"data.inventory.namespace[<namespace>][groupVersion][<kind>][<name>]"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Example referencing the Gatekeeper pod: ",Object(o.b)("inlineCode",{parentName:"li"},'data.inventory.namespace["gatekeeper"]["v1"]["Pod"]["gatekeeper-controller-manager-d4c98b788-j7d92"]'))))),Object(o.b)("h3",{id:"audit"},"Audit"),Object(o.b)("p",null,"The audit functionality enables periodic evaluations of replicated resources against the policies enforced in the cluster to detect pre-existing misconfigurations. Audit results are stored as violations listed in the ",Object(o.b)("inlineCode",{parentName:"p"},"status")," field of the failed constraint."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: ns-must-have-gk\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Namespace"]\n  parameters:\n    labels: ["gatekeeper"]\nstatus:\n  auditTimestamp: "2019-05-11T01:46:13Z"\n  enforced: true\n  violations:\n  - enforcementAction: deny\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: default\n  - enforcementAction: deny\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: gatekeeper-system\n  - enforcementAction: deny\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: kube-public\n  - enforcementAction: deny\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: kube-system\n')),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Audit interval: set ",Object(o.b)("inlineCode",{parentName:"li"},"--audit-interval=123")," (defaults to every ",Object(o.b)("inlineCode",{parentName:"li"},"60")," seconds)"),Object(o.b)("li",{parentName:"ul"},"Audit violations per constraint: set ",Object(o.b)("inlineCode",{parentName:"li"},"--constraint-violations-limit=123")," (defaults to ",Object(o.b)("inlineCode",{parentName:"li"},"20"),")"),Object(o.b)("li",{parentName:"ul"},"Disable: set ",Object(o.b)("inlineCode",{parentName:"li"},"--audit-interval=0"))),Object(o.b)("p",null,"By default, the audit will request each resource from the Kubernetes API during each cycle of the audit. To instead rely on the OPA cache, use the flag ",Object(o.b)("inlineCode",{parentName:"p"},"--audit-from-cache=true"),". Note that this requires replication of Kubernetes resources into OPA before they can be evaluated against the enforced policies. Refer to the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#replicating-data"}),"Replicating data")," section for more information."),Object(o.b)("h4",{id:"audit-using-kinds-specified-in-the-constraints-only"},"Audit using kinds specified in the constraints only"),Object(o.b)("p",null,"By default, Gatekeeper will audit all resources in the cluster. This operation can take some time depending on the number of resources."),Object(o.b)("p",null,'If all of your constraints match against specific kinds (e.g. "match only pods"), then you can speed up audit runs by setting ',Object(o.b)("inlineCode",{parentName:"p"},"--audit-match-kind-only=true")," flag. This will only check resources of the kinds specified in all ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#Constraints"}),"constraints")," defined in the cluster."),Object(o.b)("p",null,"For example, defining this constraint will only audit ",Object(o.b)("inlineCode",{parentName:"p"},"Pod")," kind:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sAllowedRepos\nmetadata:\n  name: prod-repo-is-openpolicyagent\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Pod"]\n...\n')),Object(o.b)("p",null,"If any of the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#Constraints"}),"constraints")," do not specify ",Object(o.b)("inlineCode",{parentName:"p"},"kinds"),", it will be equivalent to not setting ",Object(o.b)("inlineCode",{parentName:"p"},"--audit-match-kind-only")," flag (",Object(o.b)("inlineCode",{parentName:"p"},"false")," by default), and will fall back to auditing all resources in the cluster."),Object(o.b)("h3",{id:"log-denies"},"Log denies"),Object(o.b)("p",null,"Set the ",Object(o.b)("inlineCode",{parentName:"p"},"--log-denies")," flag to log all denies and dryrun failures.\nThis is useful when trying to see what is being denied/fails dry-run and keeping a log to debug cluster problems without having to enable syncing or looking through the status of all constraints."),Object(o.b)("h3",{id:"dry-run"},"Dry Run"),Object(o.b)("p",null,"When rolling out new constraints to running clusters, the dry run functionality can be helpful as it enables constraints to be deployed in the cluster without making actual changes. This allows constraints to be tested in a running cluster without enforcing them. Cluster resources that are impacted by the dry run constraint are surfaced as violations in the ",Object(o.b)("inlineCode",{parentName:"p"},"status")," field of the constraint."),Object(o.b)("p",null,"To use the dry run feature, add ",Object(o.b)("inlineCode",{parentName:"p"},"enforcementAction: dryrun")," to the constraint spec to ensure no actual changes are made as a result of the constraint. By default, ",Object(o.b)("inlineCode",{parentName:"p"},"enforcementAction")," is set to ",Object(o.b)("inlineCode",{parentName:"p"},"deny")," as the default behavior is to deny admission requests with any violation."),Object(o.b)("p",null,"For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: ns-must-have-gk\nspec:\n  enforcementAction: dryrun\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Namespace"]\n  parameters:\n    labels: ["gatekeeper"]\nstatus:\n  auditTimestamp: "2019-08-15T01:46:13Z"\n  enforced: true\n  violations:\n  - enforcementAction: dryrun\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: default\n  - enforcementAction: dryrun\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: gatekeeper-system\n\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"NOTE: The supported enforcementActions are ","[",Object(o.b)("inlineCode",{parentName:"p"},"deny"),", ",Object(o.b)("inlineCode",{parentName:"p"},"dryrun"),"]"," for constraints. Update the ",Object(o.b)("inlineCode",{parentName:"p"},"--disable-enforcementaction-validation=true")," flag if the desire is to disable enforcementAction validation against the list of supported enforcementActions.")),Object(o.b)("h3",{id:"exempting-namespaces-from-gatekeeper"},"Exempting Namespaces from Gatekeeper"),Object(o.b)("p",null,"Config resource can be used as follows to exclude namespaces from certain processes for all constraints in the cluster. To exclude namespaces at a constraint level, use ",Object(o.b)("inlineCode",{parentName:"p"},"excludedNamespaces")," in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#constraints"}),"constraint")," instead."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: config.gatekeeper.sh/v1alpha1\nkind: Config\nmetadata:\n  name: config\n  namespace: "gatekeeper-system"\nspec:\n  match:\n    - excludedNamespaces: ["kube-system", "gatekeeper-system"]\n      processes: ["*"]\n    - excludedNamespaces: ["audit-excluded-ns"]\n      processes: ["audit"]\n    - excludedNamespaces: ["audit-webhook-sync-excluded-ns"]\n      processes: ["audit", "webhook", "sync"]\n...\n')),Object(o.b)("p",null,"Available processes:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"audit")," process exclusion will exclude resources from specified namespace(s) in audit results."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"webhook")," process exclusion will exclude resources from specified namespace(s) from the admission webhook."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"sync")," process exclusion will exclude resources from specified namespace(s) from being synced into OPA."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"*")," includes all current processes above and includes any future processes.")),Object(o.b)("h4",{id:"exempting-namespaces-from-the-gatekeeper-admission-webhook-using---exempt-namespace-flag"},"Exempting Namespaces from the Gatekeeper Admission Webhook using ",Object(o.b)("inlineCode",{parentName:"h4"},"--exempt-namespace")," flag"),Object(o.b)("p",null,"Note that the following only exempts resources from the admission webhook. They will still be audited. Editing individual constraints is\nnecessary to exclude them from audit."),Object(o.b)("p",null,"If it becomes necessary to exempt a namespace from Gatekeeper entirely (e.g. you want ",Object(o.b)("inlineCode",{parentName:"p"},"kube-system")," to bypass admission checks), here's how to do it:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Make sure the validating admission webhook configuration for Gatekeeper has the following namespace selector:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"  namespaceSelector:\n    matchExpressions:\n    - key: admission.gatekeeper.sh/ignore\n      operator: DoesNotExist\n")),Object(o.b)("p",{parentName:"li"},"the default Gatekeeper manifest should already have added this. The default name for the\nwebhook configuration is ",Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper-validating-webhook-configuration")," and the default\nname for the webhook that needs the namespace selector is ",Object(o.b)("inlineCode",{parentName:"p"},"validation.gatekeeper.sh"))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Tell Gatekeeper it's okay for the namespace to be ignored by adding a flag to the pod:\n",Object(o.b)("inlineCode",{parentName:"p"},"--exempt-namespace=<NAMESPACE NAME>"),". This step is necessary because otherwise the\npermission to modify a namespace would be equivalent to the permission to exempt everything\nin that namespace from policy checks. This way a user must explicitly have permissions\nto configure the Gatekeeper pod before they can add exemptions.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Add the ",Object(o.b)("inlineCode",{parentName:"p"},"admission.gatekeeper.sh/ignore")," label to the namespace. The value attached\nto the label is ignored, so it can be used to annotate the reason for the exemption."))),Object(o.b)("h3",{id:"debugging"},"Debugging"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"NOTE: Verbose logging with DEBUG level can be turned on with ",Object(o.b)("inlineCode",{parentName:"p"},"--log-level=DEBUG"),".  By default, the ",Object(o.b)("inlineCode",{parentName:"p"},"--log-level")," flag is set to minimum log level ",Object(o.b)("inlineCode",{parentName:"p"},"INFO"),". Acceptable values for minimum log level are ","[",Object(o.b)("inlineCode",{parentName:"p"},"DEBUG"),", ",Object(o.b)("inlineCode",{parentName:"p"},"INFO"),", ",Object(o.b)("inlineCode",{parentName:"p"},"WARNING"),", ",Object(o.b)("inlineCode",{parentName:"p"},"ERROR"),"]",". In production, this flag should not be set to ",Object(o.b)("inlineCode",{parentName:"p"},"DEBUG"),".")),Object(o.b)("h3",{id:"enable-delete-operations"},"Enable Delete Operations"),Object(o.b)("p",null,"To enable Delete operations for the ",Object(o.b)("inlineCode",{parentName:"p"},"validation.gatekeeper.sh"),' admission webhook, add "DELETE" to the list of operations in the ',Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper-validating-webhook-configuration")," ValidatingWebhookConfiguration as seen in this deployment manifest of gatekeeper: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/open-policy-agent/gatekeeper/blob/v3.1.0-beta.10/deploy/gatekeeper.yaml#L792-L794"}),"here"),"\nNote: For admission webhooks registered for DELETE operations, use Kubernetes v1.15.0+"),Object(o.b)("p",null," So you have"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-YAML"}),"   operations:\n   - CREATE\n   - UPDATE\n   - DELETE\n")),Object(o.b)("p",null,"You can now check for deletes."),Object(o.b)("h4",{id:"viewing-the-request-object"},"Viewing the Request Object"),Object(o.b)("p",null,"A simple way to view the request object is to use a constraint/template that\ndenies all requests and outputs the request object as its rejection message."),Object(o.b)("p",null,"Example template:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: k8sdenyall\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sDenyAll\n  targets:\n    - target: admission.k8s.gatekeeper.sh\n      rego: |\n        package k8sdenyall\n\n        violation[{"msg": msg}] {\n          msg := sprintf("REVIEW OBJECT: %v", [input.review])\n        }\n')),Object(o.b)("p",null,"Example constraint:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sDenyAll\nmetadata:\n  name: deny-all-namespaces\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Namespace"]\n')),Object(o.b)("h4",{id:"tracing"},"Tracing"),Object(o.b)("p",null,"In debugging decisions and constraints, a few pieces of information can be helpful:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Cached data and existing rules at the time of the request"),Object(o.b)("li",{parentName:"ul"},"A trace of the evaluation"),Object(o.b)("li",{parentName:"ul"},"The input document being evaluated")),Object(o.b)("p",null,"Writing out this information for every request would be very expensive, and it would be hard\nto find the relevant logs for a given request. Instead, Gatekeeper allows users to specify\nresources and requesting users for which information will be logged. They can do so by\nconfiguring the ",Object(o.b)("inlineCode",{parentName:"p"},"Config")," resource, which lives in the ",Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper-system")," namespace."),Object(o.b)("p",null,"Below is an example of a config resource:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: config.gatekeeper.sh/v1alpha1\nkind: Config\nmetadata:\n  name: config\n  namespace: "gatekeeper-system"\nspec:\n  # Data to be replicated into OPA\n  sync:\n    syncOnly:\n      - group: ""\n        version: "v1"\n        kind: "Namespace"\n  validation:\n    # Requests for which we want to run traces\n    traces:\n        # The requesting user for which traces will be run\n      - user: "user_to_trace@company.com"\n        kind:\n          # The group, version, kind for which we want to run a trace\n          group: ""\n          version: "v1"\n          kind: "Namespace"\n          # If dump is defined and set to `All`, also dump the state of OPA\n          dump: "All"\n')),Object(o.b)("p",null,"Traces will be written to the stdout logs of the Gatekeeper controller."),Object(o.b)("p",null,"If there is an error in the Rego in the ConstraintTemplate, there are cases where it is still created via ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl apply -f [CONSTRAINT_TEMPLATE_FILENAME].yaml"),"."),Object(o.b)("p",null,"When applying the constraint using ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl apply -f constraint.yaml")," with a ConstraintTemplate that contains incorrect Rego, and error will occur: ",Object(o.b)("inlineCode",{parentName:"p"},'error: unable to recognize "[CONSTRAINT_FILENAME].yaml": no matches for kind "[NAME_OF_CONSTRAINT]" in version "constraints.gatekeeper.sh/v1beta1"'),"."),Object(o.b)("p",null,"To find the error, run ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl get -f [CONSTRAINT_FILENAME].yaml -oyaml"),". Build errors are shown in the ",Object(o.b)("inlineCode",{parentName:"p"},"status")," field."),Object(o.b)("h3",{id:"customizing-admission-behavior"},"Customizing Admission Behavior"),Object(o.b)("p",null,"Gatekeeper is a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-configuration"}),"Kubernetes admission webhook"),"\nwhose default configuration can be found in the ",Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper.yaml")," manifest file. By default, it is\na ",Object(o.b)("inlineCode",{parentName:"p"},"ValidatingWebhookConfiguration")," resource named ",Object(o.b)("inlineCode",{parentName:"p"},"gatekeeper-validating-webhook-configuration"),"."),Object(o.b)("p",null,"Currently the configuration specifies two webhooks: one for checking a request against\nthe installed constraints and a second webhook for checking labels on namespace requests\nthat would result in bypassing constraints for the namespace. The namespace-label webhook\nis necessary to prevent a privilege escalation where the permission to add a label to a\nnamespace is equivalent to the ability to bypass all constraints for that namespace.\nYou can read more about the ability to exempt namespaces by label ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#exempting-namespaces-from-the-gatekeeper-admission-webhook"}),"above"),"."),Object(o.b)("p",null,"Because Kubernetes adds features with each version, if you want to know how the webhook can be configured it\nis best to look at the official documentation linked at the top of this section. However, two particularly important\nconfiguration options deserve special mention: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts"}),"timeouts")," and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy"}),"failure policy"),"."),Object(o.b)("p",null,"Timeouts allow you to configure how long the API server will wait for a response from the admission webhook before it\nconsiders the request to have failed. Note that setting the timeout longer than the overall request timeout\nmeans that the main request will time out before the webhook's failure policy is invoked."),Object(o.b)("p",null,"Failure policy controls what happens when a webhook fails for whatever reason. Common\nfailure scenarios include timeouts, a 5xx error from the server or the webhook being unavailable.\nYou have the option to ignore errors, allowing the request through, or failing, rejecting the request.\nThis results in a direct tradeoff between availability and enforcement."),Object(o.b)("p",null,"Currently Gatekeeper is defaulting to using ",Object(o.b)("inlineCode",{parentName:"p"},"Ignore")," for the constraint requests. This is because\nthe webhook server currently only has one instance, which risks downtime during actions like upgrades.\nAs the theoretical availability improves we will likely change the default to ",Object(o.b)("inlineCode",{parentName:"p"},"Fail"),"."),Object(o.b)("p",null,"The namespace label webhook defaults to ",Object(o.b)("inlineCode",{parentName:"p"},"Fail"),", this is to help ensure that policies preventing\nlabels that bypass the webhook from being applied are enforced. Because this webhook only gets\ncalled for namespace modification requests, the impact of downtime is mitigated, making the\ntheoretical maximum availability less of an issue."),Object(o.b)("p",null,"Because the manifest is available for customization, the webhook configuration can\nbe tuned to meet your specific needs if they differ from the defaults."),Object(o.b)("h3",{id:"emergency-recovery"},"Emergency Recovery"),Object(o.b)("p",null,"If a situation arises where Gatekeeper is preventing the cluster from operating correctly,\nthe webhook can be disabled. This will remove all Gatekeeper admission checks. Assuming\nthe default webhook name has been used this can be achieved by running:"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"kubectl delete validatingwebhookconfigurations.admissionregistration.k8s.io gatekeeper-validating-webhook-configuration")),Object(o.b)("p",null,"Redeploying the webhook configuration will re-enable Gatekeeper."),Object(o.b)("h3",{id:"running-on-private-gke-cluster-nodes"},"Running on private GKE Cluster nodes"),Object(o.b)("p",null,"By default, firewall rules restrict the cluster master communication to nodes only on ports 443 (HTTPS) and 10250 (kubelet). Although Gatekeeper exposes its service on port 443, GKE by default enables ",Object(o.b)("inlineCode",{parentName:"p"},"--enable-aggregator-routing")," option, which makes the master to bypass the service and communicate straight to the POD on port 8443."),Object(o.b)("p",null,"Two ways of working around this:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"create a new firewall rule from master to private nodes to open port ",Object(o.b)("inlineCode",{parentName:"p"},"8443")," (or any other custom port)"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#add_firewall_rules"}),"https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#add_firewall_rules")))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"make the pod to run on privileged port 443 (need to run pod as root)"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"update Gatekeeper deployment manifest spec:"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"remove ",Object(o.b)("inlineCode",{parentName:"li"},"securityContext")," settings that force the pods not to run as root"),Object(o.b)("li",{parentName:"ul"},"update port from ",Object(o.b)("inlineCode",{parentName:"li"},"8443")," to ",Object(o.b)("inlineCode",{parentName:"li"},"443"))),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"containers:\n- args:\n  - --port=443\n  ports:\n  - containerPort: 443\n    name: webhook-server\n    protocol: TCP\n"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"update Gatekeeper service manifest spec:"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"update ",Object(o.b)("inlineCode",{parentName:"li"},"targetPort")," from ",Object(o.b)("inlineCode",{parentName:"li"},"8443")," to ",Object(o.b)("inlineCode",{parentName:"li"},"443"))),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"ports:\n- port: 443\n  targetPort: 443\n")))))),Object(o.b)("h3",{id:"running-on-openshift-4x"},"Running on OpenShift 4.x"),Object(o.b)("p",null,"When running on OpenShift, the ",Object(o.b)("inlineCode",{parentName:"p"},"nouid")," scc must be used to keep a restricted profile but being able to set the UserID."),Object(o.b)("p",null,"In order to use it, the following section must be added to the gatekeeper-manager-role Role:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"- apiGroups:\n  - security.openshift.io\n  resourceNames:\n    - anyuid\n  resources:\n    - securitycontextconstraints\n  verbs:\n    - use\n")),Object(o.b)("p",null,"With this restricted profile, it won't be possible to set the ",Object(o.b)("inlineCode",{parentName:"p"},"container.seccomp.security.alpha.kubernetes.io/manager: runtime/default")," annotation. On the other hand, given the limited amount of privileges provided by the anyuid scc, the annotation can be removed."))}p.isMDXComponent=!0},71:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),p=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(r,".").concat(u)]||b[u]||d[u]||o;return n?i.a.createElement(m,s(s({ref:t},c),{},{components:n})):i.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);